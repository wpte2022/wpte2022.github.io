<html>
<head>
<link rel="stylesheet" type="text/css" href="my.css"/>
<title>
WPTE 2022
</title>
</head>
<body>

<header>

<h1>WPTE 2022</h1>
<h1>9th International Workshop on Rewriting Techniques for Program Transformations and Evaluation</h1>

<h2>Haifa, Israel</h2>
<h3>Part of <a href="https://floc2022.org/">FLoC 2022</a>, affiliated
with <a href="https://www.cs.tau.ac.il/~nachumd/FSCD/">FSCD 2022</a></h3>
<h2>Sunday, July 31st, 2022</h2>

</header>

<h2>
News
</h2>

<h4><span style="color:red">(NEW!)</span> We will try to live stream
the workshop <s><a
href="https://us06web.zoom.us/j/84985802533?pwd=TmxWZkNsWFMwemNTTjhPRFVBenhnZz09">
over this
Zoom link</a></s> <a
href="https://us06web.zoom.us/j/89881654701?pwd=RGI1L1paOWVqQUZmNCs1QzJnS2VjUT09">over this
Zoom link</a>.</h4>
 


<h4><span style="color:red">(NEW!)</span> The
workshop schedule is available as part of the <a
href="https://easychair.org/smart-program/FLoC2022/WPTE-index.html">FLoC
program</a>.</h4>
<ul>
<li> Paper submission
  deadline: 31 May 2022 (extended, firm) </li>
 <li> Confirmed Special Issue in the
  <a href="https://www.journals.elsevier.com/journal-of-logical-and-algebraic-methods-in-programming ">Journal of Algebraic and Logical Methods in Computer Science</a></li>
  <li>We also encourage the submission of work-in-progress papers.</li>
  <li>The <a href="cfp.txt">call for papers</a> is live.</li>
  <li>The workshop date has been fixed to July 31st.</li>
</ul>

<h2>
About
</h2>

<p> The aim of WPTE is to bring together the researchers working on
program transformations, evaluation, and operationally based
programming language semantics, using rewriting methods, in order to
share the techniques and recent developments and to exchange ideas to
encourage further activation of research in this area.  </p>

<h2>
COVID-19</h2>

<p> We aim at organizing a physical workshop, with the possibility of
hybrid attendance for spearkers or participants who are unable to
attend physically due to any reason. As a backup solution, we will
organize an online workshop. See more information on the <a
href="https://floc2022.org/">FLoC website</a>.  </p>

<h2>
Previous WPTEs
</h2>

<ul>

<li>  <a href="https://www.ipl.riec.tohoku.ac.jp/wpte2021/">WPTE 2021</a> held online was
  affiliated with <a href="https://fscd2021.dc.uba.ar/">FSCD</a> 2021.</li>

<li>  <a href="http://maude.ucm.es/wpte20/">WPTE 2020</a> held online was
  affiliated with <a href="https://fscd2020.org/">FSCD</a>-<a
  href="https://ijcar2020.org/">IJCAR</a> 2020.</li>

<li>  <a href="http://nigam.info/conferences/wpte2019/main.html">WPTE
  2019</a> in Dortmund was affiliated with <a
  href="http://easyconferences.eu/fscd2019/">FSCD 2019</a>.</li>

<li>  <a
  href="http://researchers.lille.inria.fr/niehren/WPTE-2018/main.html">WPTE
  2018</a> in Oxford was affiliated with <a
  href="http://www.floc2018.org/">FLoC 2018</a> and <a
  href="http://www.cs.le.ac.uk/events/fscd2018">FSCD 2018</a>.</li>

<li>  <a href="http://www.ki.informatik.uni-frankfurt.de/WPTE17">WPTE
  2017</a> in Oxford was affiliated with <a
  href="http://www.cs.ox.ac.uk/conferences/fscd2017/index.html">FSCD
  2017</a>.</li>

<li>  <a href="https://project.inria.fr/wpte2016/program">WPTE 2016</a> in
  Porto was affiliated with <a
  href="http://fscd2016.dcc.fc.up.pt/">FSCD 2016</a>.</li>

<li>  <a href="http://www.trs.cm.is.nagoya-u.ac.jp/event/wpte2015">WPTE
  2015</a> in Warsaw was affiliated with <a
  href="http://rdp15.mimuw.edu.pl/">RDP 2015</a>.</li>

<li>  <a href="http://www.ki.informatik.uni-frankfurt.de/WPTE14">WPTE
  2014</a> in Vienna was affiliated with <a
  href="http://www.easychair.org/smart-program/VSL2014/RTATLCA-cfp.html">RTA/TLCA
  2014</a>.</li>
  
</ul>

<h2>
Topics of Interest
</h2>

<ul>
  
<li>Correctness of program transformations, optimizations and
  translations.</li>
  
<li>Program transformations for proving termination, confluence, and
  other properties.</li>
  
  <li>Correctness of evaluation strategies.</li>
  
<li>Operational semantics of programs, operationally-based program
  equivalences such as contextual equivalences and bisimulations.</li>
  
<li>Cost-models for arguing about the optimizing power of
  transformations and the costs of evaluation.</li>
  
<li>Program transformations for verification and theorem proving
  purposes.</li>
  
<li>Translation, simulation, equivalence of programs with different
  formalisms, and evaluation strategies.</li>
  
<li>Program transformations for applying rewriting techniques to
  programs in specific programming languages.</li>
  
<li>Program transformations for program inversions and program
  synthesis.</li>
  
<li>Program transformation and evaluation for Haskell and
  rewriting.</li>
  
</ul>

<h2>
Important Dates
</h2>

<ul>

  <li>Paper: 31 May 2022 (extended, firm)</li>

  <li> New category: work-in-progress papers (upper limit of 10 pages)</li>

  <li> <b> Acceptance notifications: 15 June 2022 </b> </li>

  <li> Final version: 29 June 2022 </li>

  <li> <b> Workshop: Sunday, 31 July 2022 </b> </li>

  <li> <b> Formal post-proceedings: autumn 2022 (TBC) </b> </li>
  
</ul>

<h2>
Invited Talk
</h2>

<p><a href="https://akihisayamada.github.io/">Akihisa YAMADA</a>, National Institute of Advanced Industrial Science
and Technology (AIST), Japan</p>

<div class="pad">
<h4>Transforming Text to (and from) XML</h4>
<p> In industry, there is a critical need for complying with laws,
standards, and guidelines.
However, there are hundreds of (versions of) international and regional
standards and guidelines,
and each of them has hundreds of clauses, referring to each other.
In AIST, we are developing an XML-based framework to support human
developers to navigate the vast amount of documents. </p>

<p> In this talk, I will introduce a Text-to-XML structuring tool TXtruct,
a core ingredient of the aforementioned framework.</p>

<p> TXtruct is a language that can describe a text or XML grammar, and at
the same time can describe a transformer.
Despite the strength, the TXtruct interpreter is implemented in an
elegant and minimalistic way, based on a string-diagrammatic semantics.
We will discuss some important properties such as termination,
productivity, and invertibility. </p>

<p> We will also explore the potential applications in the Termination
Competitions and Confluence Competitions, where thousands of term
rewrite systems are given in a different formats.</p>
</div>

<h2>
Program
</h2>

<p>Please check the latest version of the <a
href="https://easychair.org/smart-program/FLoC2022/WPTE-index.html">workshop schedule</a>.</p>

<h2>
Accepted Papers
</h2>

	<script language="javascript">

	 function toggleVisible(divId) {
	     var div = document.getElementById(divId);
	     if (div) {
		 if (div.style.display != 'block') {
		     div.style.display = 'block';
		 } else {
		     div.style.display = 'none';
		 }
	     }
	 }

	</script>

<ul>

  <li> Christopher Brown, Adam Barwell, Simon Thompson, Susmit Sarkar
  and Edwin Brady:

  Towards a Refactoring Tool for Dependently-Typed Programs (work in
  progress)

  <a href="#p1" onclick="toggleVisible('p1'); return false;">[Abstract]</a>

  <div class="abstract" id="p1">
While there is considerable work on refactoring functional programs, so far this had not extended to dependently-typed programs. In this paper, we begin to explore this space by looking at a range of transformations related to indexed data and functions.
  </div>

  </li>

  <li>
  David Sabel and Manfred Schmidt-Schauss:
  Program Equivalence in a Typed Probabilistic Call-by-Need Functional Language

  <a href="#p2" onclick="toggleVisible('p2'); return false;">[Abstract]</a>

  <div class="abstract" id="p2">
We introduce a call-by-need variant of PCF with a binary probabilistic fair choice operator. We define its operational semantics and contextual equivalence as program equivalence, where the expected convergence is only observed on numbers. We investigate another program equivalence that views two closed expressions as distribution-equivalent if evaluation generates the same distribution on the natural numbers. We show that contextual equivalence implies distribution-equivalence. Future work is to provide a full proof of the opposite direction.
  </div>
  </li>

  <li>
  György Sághi, Péter Bereczky and Dániel Horpácsi:
  A Machine-Checked Formalisation of Erlang Modules

  <a href="#p3" onclick="toggleVisible('p3'); return false;">[Abstract]</a>

  <div class="abstract" id="p3">
This paper contributes to our long-term goal of defining the Erlang programming language in the Coq proof assistant, ultimately allowing us to formally reason about Erlang programs and their transformations. In previous work, we have described a sequential subset of the core language of Erlang in different semantics definition styles, which is extended with the module system in the present formalization. In particular, we define modules and inter-module calls in natural and functional big-step semantics, and we prove their equivalence. Last but not least, we validate the formal definition with respect to the reference implementation. The formal theories are machine-checked in Coq.
  </div>
  
  </li>

  <li>
  Kasper Hagens, Cynthia Kop and Wouter Brozius:
  Extending a Lemma Generation Approach for Rewriting Induction on Logically Constrained Term Rewriting Systems
  <a href="#p4" onclick="toggleVisible('p4'); return false;">[Abstract]</a>

  <div class="abstract" id="p4">
When transforming a program into a more efficient version (for example translating a recursive program into an imperative program), it is important to guarantee that the input-output-behavior remains the same. One approach to assure this uses so-called Logically Constrained Term Rewriting Systems (LCTRSs). Two versions of a program are translated into LCTRSs and compared in a proof system (Rewriting Induction). Proving their equivalence in this system often requires the introduction of a lemma. In this paper we review a lemma generation approach by Fuhs, Kop and Nishida and propose two possible extensions.
  </div>
  </li>

  <li>
  Misaki Kojima and Naoki Nishida:
  On Reducing Non-Occurrence of Specified Runtime Errors to All-Path Reachability Problems of Constrained Rewriting
  <a href="#p5" onclick="toggleVisible('p5'); return false;">[Abstract]</a>

  <div class="abstract" id="p5">
A concurrent program with semaphore-based exclusive control can be transformed into a logically constrained term rewrite system that is computationally equivalent to the program. In this paper, we first propose a framework to reduce the non-occurrence of a specified runtime error in the program to an all-path reachability problem of the transformed logically constrained term rewrite system. Here, an all-path reachability problem is a pair of state sets and is true if every finite execution path starting with a state in the first set and ending with a terminating state includes a state in the second set. Then, as a case study, we show how to apply the framework to the race-freeness of semaphore-based exclusive control in the program. Finally, we show a simplified variant of a proof system for all-path reachability problems.
  </div>
  </li>

  <li>
  Naoki Nishida, Misaki Kojima and Takumi Kato:
  On Transforming Imperative Programs into Logically Constrained Term Rewrite Systems via Injective Functions from Configurations to Terms
  <a href="#p6" onclick="toggleVisible('p6'); return false;">[Abstract]</a>

  <div class="abstract" id="p6">
To transform an imperative program into a logically constrained term rewrite system (LCTRS, for short), previous work converts a statement list to rewrite rules in a stepwise manner, and proves the correctness along such a conversion and the big-step semantics of the program. On the other hand, the small-step semantics of a programming language comprises of inference rules that define transition steps of configurations. Partial instances of such inference rules are almost the same as rewrite rules in the transformed LCTRS. In this paper, we aim at establishing a framework for plain definitions and correctness proofs of transformations from programs into LCTRSs. To this end, for the transformation in previous work, we show an injective function from configurations to terms, and reformulate the transformation by means of the injective function. The injective function maps a transition step to a reduction step, and results in a plain correctness proof.
  </div>
  </li>

  <li>
  Péter Hegyi, Dániel Lukács and Máté Tejfel:
  Refactoring Steps for P4 (work in progress)
  <a href="#p7" onclick="toggleVisible('p7'); return false;">[Abstract]</a>

  <div class="abstract" id="p7">
P4 is a domain specific programming language developed mainly to describe data plane layer of packet processing algorithms of different network devices (e.g. switches, routers). The language has special domain-specific constructs (e.g. match/action tables) that cannot be found in other languages and as such there is no existing methodology yet for refactoring these constructs. The paper introduces the definition of some P4 specific refactoring steps. The proposed steps are implemented using P4Query an analyzer framework dedicated to P4.
  </div>
  </li>

  <li>
  Shujun Zhang and Naoki Nishida:
  On Transforming Rewriting-Induction Proofs for Logical-Connective-Free Sequents into Cyclic Proofs
  <a href="#p8" onclick="toggleVisible('p8'); return false;">[Abstract]</a>

  <div class="abstract" id="p8">
A GSC-terminating and orthogonal inductive definition set (IDS, for short) of first-order predicate logic can be transformed into a many-sorted term rewrite system (TRS, for short) such that a quantifier-free sequent is valid w.r.t. the IDS if and only if a term equation representing the sequent is an inductive theorem of the TRS. Under certain assumptions, it has been shown that a quantifier- and cut-free cyclic proof of a sequent can be transformed into a rewriting-induction (RI, for short) proof of the corresponding term equation. The RI proof can be transformed back into the cyclic proof, but it is not known how to transform arbitrary RI proofs into cyclic proofs. In this paper, we show that for a quantifier- and logical-connective-free sequent, if there exists an RI proof of the corresponding term equation, then there exists a cyclic proof of some sequent w.r.t. some IDS such that the cyclic proof ensures the validity of the initial sequent. To this end, we show a transformation of the RI proof into such a cyclic proof, a sequent, and an IDS.
  </div>
  </li>

  <li>
  Vlad Rusu and David Nowak:
  Sufficiently Complete Partial Orders: Towards Corecursion Without Corecursion in Coq
  <a href="#p9" onclick="toggleVisible('p9'); return false;">[Abstract]</a>

  <div class="abstract" id="p9">
Coinduction is an important concept in functional programming. To formally prove properties of corecursive functions one can try to define them in a proof assistant such as Coq. But there are strong limitations on the corecursive functions that can be defined. In particular, one cannot freely mix corecursion with recursion. In this paper we introduce the notion of Sufficiently Complete Partial Order (SCPO) that enables us to transform a program's coinductive types by means of "sufficiently completing" inductive types, thereby escaping Coq's builtin limitations. We also show how corecursive functions can be defined on SCPOs without actually using corecursion, by adapting some recent work where we show how this can be done by means of the unique solution of a fixpoint equation.
  </div>
  </li>

</ul>
  
<h2>
Program Committee
</h2>
<ul>
<li><a href="http://elp.webs.upv.es/members/alpuente/">María Alpuente</a>, Universitat Politècnica de València, Spain</li>
<li><a href="https://users.dimi.uniud.it/~demis.ballis/">Demis Ballis</a>, University of Udine, Italy</li>
<li><a href="https://chrisb.host.cs.st-andrews.ac.uk/">Christopher Brown</a>, University of St Andrews, UK</li>
<li><a href="https://profs.info.uaic.ro/~stefan.ciobaca/">Stefan Ciobaca</a>, Alexandru Ioan Cuza University, Romania (co-chair)</li>
<li><a href="http://egunter.cs.illinois.edu/">Elsa Gunter</a>, University of Illinois, Urbana - Champaign</li>
<li><a href="http://daniel-h.web.elte.hu/">Dániel Horpácsi</a>, Eötvös Loránd University, Hungary</li>
<li><a href="https://group-mmm.org/~s-katsumata/index-e.html">Shin-Ya Katsumata</a>, National Institute of Informatics, Japan</li>
<li><a href="https://kentaro-kikuchi.github.io/">Kentaro Kikuchi</a>, Tohoku University, Japan</li>
<li><a href="https://www.cs.ru.nl/~cynthiakop/index_en.html">Cynthia Kop</a>, Radboud University, The Netherlands</li>
<li><a href="https://sites.google.com/a/depinfonancy.net/pem/">Pierre-Etienne Moreau</a>, Université de Lorraine, France</li>
<li><a href="https://www.kurims.kyoto-u.ac.jp/~kmuroya/">Koko Muroya</a>, Kyoto University, Japan</li>
<li><a href="https://www.riec.tohoku.ac.jp/~ksk/en/">Keisuke Nakano</a>, Tohoku University, Japan (co-chair)</li>
<li><a href="https://www.trs.css.i.nagoya-u.ac.jp/person/sakai/index.html.en">Masahiko Sakai</a>, Nagoya University, Japan</li>
</ul>

<h2>
Steering Committee
</h2>

      <ul class="pc"> <li> <a
        href="https://members.loria.fr/HCirstea/">Horatiu Cirstea</a>,
        LORIA, Université de Lorraine, France </li> <li> <a
        href="http://users.dsic.upv.es/~sescobar/">Santiago
        Escobar</a>, Universitat Politècnica de València </li> <li> <a
        href="http://researchers.lille.inria.fr/~niehren">Joachim
        Niehren</a>, Inria, Lille.  </li> <li> <a
        href="http://www.sakabe.i.is.nagoya-u.ac.jp/~nishida/">Naoki
        Nishida</a>, Nagoya University </li> <li> <a
        href="http://www.davidsabel.de/">David Sabel</a>, LMU Munich
        </li> <li> <a
        href="http://www.ki.informatik.uni-frankfurt.de/persons/schauss/schauss.html">Manfred
        Schmidt-Schauß</a>, Goethe-University, Frankfurt am Main </li>
        </ul>

<h2>
Contact
</h2>
Please contact wpte2022@easychair.org.

</body>
</html>
